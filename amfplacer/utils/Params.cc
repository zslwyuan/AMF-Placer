/**
 * @file DesignInfo.cc
 * @author Tingyuan LIANG (tliang@connect.ust.hk)
 * @brief This implementation file contains APIs' implementation for a standalone design netlist.
 * @version 0.1
 * @date 2021-06-03
 *
 * @copyright Copyright (c) 2021 Reconfiguration Computing Systems Lab, The Hong Kong University of Science and
 * Technology. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
#include <boost/filesystem.hpp>
#include <iostream>
#include <omp.h>
#include "Params.h"
#include "simpleJSON.h"
#include "dumpZip.h"

Params::Params()
{
    init();
}

Params::Params(const std::string &JSONFileName)
{
    init();
    read(JSONFileName);
}

void Params::init()
{
    GlobalPlacerPrintHPWL = true;
    DumpClockUtilization = true;
    // ClockPeriod = 10;
    // SARestartNum = 600;
    // SAIterNum = 30000000;
    MacroLegalizationVerbose = false;
    CLBLegalizationVerbose = false;
    RandomInitialPlacement = true;
    DrawNetAfterEachIteration = false;
    ClusterPlacerVerbose = false;
    GlobalPlacerVerbose = false;
    SpreaderSimpleExpland = false;
    pseudoNetWeightConsiderNetNum = true;
    disableSpreadingConvergeRatio = false;
    drawClusters = false;
    MKL = false;
    useUnconstrainedCG = true;
    // PseudoNetWeight = 0.0025;
    // GlobalPlacementIteration = 30;
    // clockRegionXNum = 5;
}

bool Params::read(const std::string &JSONFileName)
{
    // std::map<std::string, std::string> JSON;
    // JSON = parseJSONFile(JSONFileName);

    // assert(JSON.find("vivadoExtractDevicePath") != JSON.end());
    // assert(JSON.find("specialPinOffsetPath") != JSON.end());
    // assert(JSON.find("vivadoExtractDesignPath") != JSON.end());
    // assert(JSON.find("cellType2fixedAmoPath") != JSON.end());
    // assert(JSON.find("cellType2sharedCellTypePath") != JSON.end());
    // assert(JSON.find("sharedCellType2BELtypePath") != JSON.end());
    // assert(JSON.find("GlobalPlacementIteration") != JSON.end());
    // if (JSON.find("dumpDirectory") != JSON.end())
    // {
    //     if (!fileExists(JSON["dumpDirectory"]))
    //         assert(boost::filesystem::create_directories(JSON["dumpDirectory"]) &&
    //                "the specified dump directory should be created successfully.");
    // }


    // omp_set_num_threads(std::stoi(JSON["jobs"]));
    // if (JSON.find("jobs") != JSON.end())
    // {
    //     omp_set_num_threads(std::stoi(JSON["jobs"]));
    // }
    // else
    // {
    //     omp_set_num_threads(1);
    // }

    // vivadoExtractDesignPath = JSON["vivadoExtractDevicePath"];

    // vivadoExtractDevicePath = JSON["vivadoExtractDevicePath"];

    // specialPinOffsetPath = JSON["specialPinOffsetPath"];

    // cellType2fixedAmoPath = JSON["cellType2fixedAmoPath"];

    // cellType2sharedCellTypePath = JSON["cellType2fixedAmoPath"];

    // sharedCellType2BELtypePath = JSON["cellType2fixedAmoPath"];

    // mergedSharedCellType2sharedCellType = JSON["cellType2fixedAmoPath"];
    // //==> the location of a information file indicating some macros which cannot be identified by AMF-Placer which we can detect in Vivado [DESIGN]
    // unpredictableMacroDesignPath = JSON["cellType2fixedAmoPath"];
    // // ==> the location of a information file indicating some elements, locations of which are fixed on the device [DESIGN]
    // fixedUnitsDesignPath = JSON["cellType2fixedAmoPath"];
    // // clock file ==>  (Optional) the location of a information file indicating the clock driver pins in the design [DESIGN]
    // clockDesignPath = JSON["cellType2fixedAmoPath"];
    // //==> (Optional) the location of a information file indicating some user-defined clusters for optimization [DESIGN]
    // designCluster = JSON["cellType2fixedAmoPath"];
    // // ==> (Optional) the location where the information of clusters generated by initial partitioning should be dumped. [DEBUG]
    // dumpClusterPath = JSON["cellType2fixedAmoPath"];
    // //"dumpClusterSAPath": "", // ==> (Optional) the location where the trace of the SA procedure should be dumped. [DEBUG]
    // dumpClusterSAPath = JSON["cellType2fixedAmoPath"];
    // // ==> (Optional) the location where the information of CLB legalization should be dumped. [DEBUG]
    // DumpCLBLegalization = JSON["cellType2fixedAmoPath"];
    // //// "SLICEL_LUT":  ==> (Optional) the location where the information of SLICEL_LUT density should be dumped. [DEBUG]
    // SLICEL_LUT = JSON["cellType2fixedAmoPath"];
    // //// "DumpLUTFFCoordTrace":"" //  ==> (Optional) the location where the trace of LUT/FF coordinate change should be dumped. [DEBUG]
    // DumpLUTFFCoordTrace = JSON["cellType2fixedAmoPath"];
    // // ==> (Optional) the location where the trace of CARRY coordinate change should be dumped. [DEBUG]
    // DumpCARRYCoordTrace = JSON["cellType2fixedAmoPath"];
    // // ==> (Optional) the location where the trace of macros coordinate change should be dumped. [DEBUG]
    // dumpMacroDensity = JSON["cellType2fixedAmoPath"];
    // //// "Dump Cell Density":"" ,// ==> (Optional) the location where the trace of standard cells coordinate change should be dumped. [DEBUG]
    // dumpCellDensityPath = JSON["cellType2fixedAmoPath"];
    // //// "DumpLUTCoordTrace": "" ,//==> (Optional) the location where the trace of LUT coordinate change should be dumped. [DEBUG]
    // DumpLUTCoordTrace = JSON["cellType2fixedAmoPath"];
    // //// "DumpDSPCoordTrace":"" ,// ==> (Optional) the location where the trace of DSP coordinate change should be dumped. [DEBUG]
    // DumpDSPCoordTrace = JSON["cellType2fixedAmoPath"];
    // //// "DumpFFCoordTrace": "" ,// ==> (Optional) the location where the trace of FF coordinate change should be dumped. [DEBUG]
    // DumpFFCoordTrace = JSON["cellType2fixedAmoPath"];
    // //// "DumpAllCoordTrace" : "" ,// ==> (Optional) the location where the trace of All elements' coordinate change should be dumped. [DEBUG]
    // DumpAllCoordTrace = JSON["cellType2fixedAmoPath"];
    // //"GlobalPlacerPrintHPWL": "" ,// ==> (Optional) indicate whether prout the detailed changes of HPWL during global placement. [DEBUG]
    // GlobalPlacerPrintHPWL = JSON["GlobalPlacerPrintHPWL"] == "true";
    // //"DumpCLBPacking" : "" ,// ==> (Optional) indicate where to dump the information of CLB packing
    // DumpCLBPacking = JSON["cellType2fixedAmoPath"];
    // //"DumpLUTFFPair": "" ,// ==> (Optional) indicate where to dump the information of LUT-FF pairing
    // DumpLUTFFPair = JSON["cellType2fixedAmoPath"];
    // //"DumpClockUtilization": "" ,// ==> (Optional) indicate whether prout the detailed changes of clock utilization [DEBUG]
    // DumpClockUtilization = JSON["cellType2fixedAmoPath"];
    // ClockPeriod;
    // //// "DumpMacroLegalization" : "" ,// ==> (Optional) indicate where prout macro legalization information [DEBUG]
    // DumpMacroLegalization;
    // //// "MacroLegalizationVerbose" : "" ,//==> (Optional:default "false") indicate whether prout DSP/BRAM macro legalization information during runtime [DEBUG]
    // MacroLegalizationVerbose;
    // //// "CLBLegalizationVerbose" :  "" ,//==> (Optional:default "false") indicate whether prout CLB legalization information during runtime [DEBUG]
    // CLBLegalizationVerbose;
    // //"Simulated Annealing restartNum":"", //  ==> a number indicate how many times the SA procedure should restart [PLACER]
    // SARestartNum;
    // //"Simulated Annealing IterNum": "" ,// ==> a number indicate the total iteration number the SA procedure should conduct [PLACER]
    // SAIterNum;
    // //// "RandomInitialPlacement" :"" //  ==> (Optional:default "false") indicate whether the initial placement is randomly generated [PLACER]
    // RandomInitialPlacement;
    // //"DrawNetAfterEachIteration":  "" ,//==> (Optional:default "false") indicate whether use OpenGL to draw the nets after each iteration of SA procedure [PLACER]
    // DrawNetAfterEachIteration;
    // //"PseudoNetWeight": "" ,//==> indicate the initial pseudo net weight which controls the placer convergence speed. [PLACER]
    // PseudoNetWeight;
    // //"GlobalPlacementIteration": "" ,//==> indicate the total number of the global placement iterations [PLACER]
    // GlobalPlacementIteration;
    // //"clockRegionXNum":"" ,// ==> indicate how many clock region in a row on the device [DEVICE]
    // clockRegionXNum;
    // //"clockRegionYNum":  "" ,//==> indicate how many clock region in a column on the device [DEVICE]
    // clockRegionYNum;
    // //"clockRegionDSPNum": "" ,//==> indicate the threshold number of DSPs in a clock region during initial SA placement [PLACER]
    // clockRegionDSPNum;
    // //"clockRegionBRAMNum": "" ,//==> indicate the threshold number of BRAMs in a clock region during initial SA placement [PLACER]
    // clockRegionBRAMNum;
    // //"jobs": "" ,// ==> indicate the parallelism of the placer [PLACER]
    // jobs;
    // //"y2xRatio": "" ,// ==> indicate the weight of Y routing net compared to X routing net [PLACER]
    // y2xRatio;
    // //"ClusterPlacerVerbose": "" ,//==> (Optional:default "false") indicate whether the SA cluster placer prouts detailed information during runtime [DEBUG]
    // ClusterPlacerVerbose;
    // //"GlobalPlacerVerbose":  "" ,//==> (Optional:default "false") indicate whether the global placer prouts detailed information during runtime [DEBUG]
    // GlobalPlacerVerbose;
    // //"DirectMacroLegalize": "" ,//==> (Optional:default "false") indicate whether AMFPlacer use direct macro legalization instread of the progressive legalization (2-phase legalization)
    // DirectMacroLegalize;
    // //// "SpreaderSimpleExpland":  "" ,//==> (Optional:default "false") indicate whether the cell spreader finds the cell spreading window in a simple approach [PLACER]
    // SpreaderSimpleExpland;
    // //// "pseudoNetWeightConsiderNetNum" : "" ,// ==> (Optional:default "true") indicate whether the wirelength optimizer considers the interconnection density for psuedo net weight [PLACER]
    // pseudoNetWeightConsiderNetNum;
    // //// "disableSpreadingConvergeRatio" :"" ,// ==> (Optional:default "false") indicate whether the cell spreader utilizes forget-rate-based cell spreading location update [PLACER]
    // disableSpreadingConvergeRatio;
    // //"drawClusters": "" ,//==> (Optional:default "false") indicate whether the SA placer draws the cluster placement with OpenGL [DEBUG]
    // drawClusters;
    // //"MKL": "" ,//==> (Optional:default "false") indicate whether wirelength optimizer is based on MKL library when using OSQP placer, which can set constraints for the quadratic model [PLACER]
    // MKL;
    // //"dumpDirectory": "" ,//==> indicate where the "DUMP" files should be located. [PLACER]
    // dumpDirectory;
    // ////"useUnconstrainedCG" : "" ,// ==>(Optional:default "true") indicate whether wirelength optimizer uses Eigen3, which cannot set constraints, to solve the quadratic problem. If false, OSQP solver which can set constraints for the quadratic model, will be involved to replace Eigen3. [PLACER]
    // useUnconstrainedCG;

    // return true;
}

Params::~Params()
{
}
